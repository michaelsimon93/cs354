# cs354_projects

These projects were done for my cs354 - Machine Organization and Programming course in the Spring of 2015 at the University of Wisconsin. Below are the descriptions for each project:

p1:
The purpose of this program is to quickly become good at writing C programs, gaining the experience of working in a non-object oriented language. Arrays, command-line arguments, file I/O, pointers, and structures are used. You will write 3 C programs. To begin with, you are given the program generate. Running this program generates a set of integers. The generate program writes two's complement integer representations to a file; this representation is often called binary output. It also prints out the ASCII version of the integers to stdout (the display), placing each value on its own line. You will be writing programs that work with two types of files: binary and ASCII. 

p2:
There are two main objectives of this project. The first is to quickly become familiar with x86 assembly language. The second relates to the first: to gain some familiarity with powerful tools that help with this process, namely gdb (the debugger) and objdump (the disassembler). You will be defusing a series of binary bombs. The idea is simple: each bomb is just an executable program, which expects five inputs from you, the bomb defusing expert. If you type in the right values, you successfully defuse the bomb. If not, the bomb explodes! The challenge is to figure out the inputs expected by each of the four bombs. To do this, use two tools: gdb and objdump. 

p3:
The purpose of this program is gain insight into the asynchronous nature of interrupts, and handling interrupts and traps, while expanding C programming skills. Write a C program called intdate.c that is composed of two parts. One part is the main program, which does absolutely nothing in an infinite loop. Before entering the infinite loop, the main program will set up what is to happen when an alarm goes off 3 seconds later. When the alarm goes off, this causes a SIGALRM interrupt to signal the program. This interrupt is to be caught by the program, and handled by the second part of the program, an interrupt handler. This handler function is to print out the current time, in the same format as the Unix date program, re-arm the alarm to go off three seconds later, and then return back to the main program (which continues its infinite loop doing nothing). Once the periodic printing of the time is working, add to the program to do something other than exit the program the first time a Control-c is typed. This extension to program only exits after the user types Control-c 5 times. Set up a SIGINT handler (using sigaction() to set up the call back function). The SIGINT handler either prints how many more times Control-c must be typed before exiting, or it prints that it caught the 5th one and it calls exit(). The alarm interrupt handler will need to re-arm the alarm each time it is called. Since both main() and the alarm handler both need to know/use the number of seconds in order to arm the alarm, make this value a global variable. Interrupt handlers are not invoked by another function within the program, so they cannot receive parameters from another function in the program. You will also need a global variable to keep track of the number of times a Control-c has been typed. It is only used by the SIGINT handler, but it needs to exist (single instantiation) the entire time that the program runs. For the next program, write a simple program that loops (forever) to
1) prompt for and read in one integer value (followed by the newline)
2) prompt for and read in a second integer value (followed by the newline)
3) calculate the quotient and remainder of doing the integer division operation: int1 / int2, printing these results, and keeping track of how many division operations were successfully completed.

p4: 
The purpose of this assignment is to understand more about how caches work, learning a bit about simulation along the way, and picking up introductory skills in generating a Makefile. For this assignment, you will use a program called pin that produces cache performance statistics, given cache parameters and an executable. pin runs the executable to internally produce a series of address traces. These are the ordered set of addresses that a program generates as it runs. They represent the addresses read from or written to as the program runs. Each address may represent a read for the instruction fetch or a read or write to a variable stored in memory. The address traces are then used internally with a cache simulator. The cache simulator is a program that acts as if it is a cache, and for each trace, does a look up to determine if that address causes a cache hit or a cache miss. The simulator tallies the hits/misses, and when it has completed simulation of all the traces, it prints these statistics for you.

p5: 
The purpose of this program is to further increase C programming skills, working a lot more with pointers and using Makefiles. For this assignment, you will be given the structure for a simple shared library that implements the memory allocation functions malloc() and free(). Everything is present, except for the definitions of those two functions, called Mem_Alloc() and Mem_Free() in this library.
